class Node
  attr_accessor :value, :left, :right

  def initialize(value, left = nil, right = nil)
    @value = value
    @left = left
    @right = right
  end
end

def level_order_traversal(root)
  return [] if root.nil?

  result = [] # to store the traversal result
  queue = [root] # enqueue the root node

  until queue.empty?
    level_size = queue.size
    current_level = []

    level_size.times do
      node = queue.shift
      current_level << node.value

      queue << node.left unless node.left.nil?
      queue << node.right unless node.right.nil?
    end

    result << current_level
  end

  result
end

if __FILE__ == $PROGRAM_NAME
  root = Node.new(1, Node.new(2), Node.new(3))

  puts "Expecting: [[1], [2, 3]]"
  print level_order_traversal(root)

  puts
  puts

  root = Node.new(10, Node.new(20, Node.new(9), Node.new(22)), Node.new(30))

  puts "Expecting: [[10], [20, 30], [9, 22]]"
  print level_order_traversal(root)

  puts
  puts

  def test_level_order_traversal
    # Test case 1: Tree with three nodes
    root1 = Node.new(1)
    root1.left = Node.new(2)
    root1.right = Node.new(3)
    expected_output1 = [[1], [2, 3]]
    actual_output1 = level_order_traversal(root1)
    puts "Test case 1: #{actual_output1 == expected_output1 ? 'Passed' : 'Failed'}"

    # Test case 2: Tree with multiple levels
    root2 = Node.new(10)
    root2.left = Node.new(20)
    root2.right = Node.new(30)
    root2.left.left = Node.new(9)
    root2.left.right = Node.new(22)
    expected_output2 = [[10], [20, 30], [9, 22]]
    actual_output2 = level_order_traversal(root2)
    puts "Test case 2: #{actual_output2 == expected_output2 ? 'Passed' : 'Failed'}"

    # Test case 3: Empty tree
    root3 = nil
    expected_output3 = []
    actual_output3 = level_order_traversal(root3)
    puts "Test case 3: #{actual_output3 == expected_output3 ? 'Passed' : 'Failed'}"

    # Test case 4: Tree with one node
    root4 = Node.new(5)
    expected_output4 = [[5]]
    actual_output4 = level_order_traversal(root4)
    puts "Test case 4: #{actual_output4 == expected_output4 ? 'Passed' : 'Failed'}"
  end

  test_level_order_traversal
end
  #{# Don't forget to add your own!#{}}

# Please add your pseudocode to this file  Class Node attr_ accessor : value, : left, :right
#def intialize(value, left = nil, right = nil)
#@value=value
#@left = left
#r@right = right
# end end --- the node objects and acess their value, left , and right attributes utilizing getter and setter methods automatically generated by attr_acessor.
# And a written explanation of your solution
#We then iterate over the elements in the queue until it becomes empty. In each iteration, we determine the size of the current level (number of nodes in the queue) and create an empty current_level array to store the values of the nodes in the current level.
#For each node in the current level, we dequeue it from the front of the queue, add its value to the current_level array, and enqueue its left and right children (if they exist).
#After processing all the nodes in the current level, we append the current_level array to the result array.
#Lastly, we return the result array, which contains the level-order traversal of the tree.

# def level_order_traversal(root)
#return [] if root.nil?
#result =[] # to store the traversal result
#queue = [root] # enqueue the root node
#until queue.empty?
#level_size = queeue.empty?
#Level_size =quee.size
#current_level =[]
#level_size.times do node = queue.shift
#ccurrent_level <<node.value
# queue <<node.left unless node.left.nil?
#queue <<node.right unless node.right.nil?
#end
#result <,current_level
#end
#result
#end
# in this code we begin from handling the edge case where the root is nill. we form a empty result array to storing  the raversal result while intializing a queue frrom the node code.

#
